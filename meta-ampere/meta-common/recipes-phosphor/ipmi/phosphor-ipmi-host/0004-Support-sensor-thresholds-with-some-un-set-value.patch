From fad9a56a77918e61970eb241e7cba75c29ed15db Mon Sep 17 00:00:00 2001
From: Hieu Huynh <hieuh@os.amperecomputing.com>
Date: Fri, 24 Jun 2022 10:16:33 +0000
Subject: [PATCH 4/8] Support sensor thresholds with some un-set value

For the sensors that does not support the threshold values such as
WarningLow, WarningHigh, CriticalLow, CriticalHigh. As defined by SDR
definition, these values should be 'na'.

Signed-off-by: Hieu Huynh <hieuh@os.amperecomputing.com>
---
 sensorhandler.cpp | 97 ++++++++++++++++++++++++++---------------------
 1 file changed, 53 insertions(+), 44 deletions(-)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index 06ae286..2f6c569 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -688,61 +688,70 @@ get_sdr::GetSensorThresholdsResponse
     }
 
     ipmi::PropertyMap warnThresholds;
-    ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
+    try
+    {
+        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
                                     warningThreshIntf, warnThresholds);
-    if (!ec)
+    }
+    catch(const std::exception& e)
     {
-        double warnLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                    warnThresholds["WarningLow"]);
-        double warnHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                     warnThresholds["WarningHigh"]);
+        // No warning thresholds
+    }
+    double warnLow = ipmi::mappedVariant<double>(warnThresholds,
+            "WarningLow", std::numeric_limits<double>::quiet_NaN());
+    double warnHigh = ipmi::mappedVariant<double>(warnThresholds,
+            "WarningHigh", std::numeric_limits<double>::quiet_NaN());
 
-        if (std::isfinite(warnLow))
-        {
-            warnLow *= std::pow(10, info.scale - info.exponentR);
-            resp.lowerNonCritical = static_cast<uint8_t>(
-                (warnLow - info.scaledOffset) / info.coefficientM);
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::NON_CRITICAL_LOW_MASK);
-        }
+    if (std::isfinite(warnLow))
+    {
+        warnLow *= std::pow(10, info.scale - info.exponentR);
+        resp.lowerNonCritical = static_cast<uint8_t>(
+            (warnLow - info.scaledOffset) / info.coefficientM);
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::NON_CRITICAL_LOW_MASK);
+    }
 
-        if (std::isfinite(warnHigh))
-        {
-            warnHigh *= std::pow(10, info.scale - info.exponentR);
-            resp.upperNonCritical = static_cast<uint8_t>(
-                (warnHigh - info.scaledOffset) / info.coefficientM);
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::NON_CRITICAL_HIGH_MASK);
-        }
+    if (std::isfinite(warnHigh))
+    {
+        warnHigh *= std::pow(10, info.scale - info.exponentR);
+        resp.upperNonCritical = static_cast<uint8_t>(
+            (warnHigh - info.scaledOffset) / info.coefficientM);
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::NON_CRITICAL_HIGH_MASK);
     }
 
     ipmi::PropertyMap critThresholds;
-    ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
+    try
+    {
+        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
                                     criticalThreshIntf, critThresholds);
-    if (!ec)
+    }
+    catch(const std::exception& e)
     {
-        double critLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                    critThresholds["CriticalLow"]);
-        double critHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                     critThresholds["CriticalHigh"]);
+        // No critical thresholds
+    }
 
-        if (std::isfinite(critLow))
-        {
-            critLow *= std::pow(10, info.scale - info.exponentR);
-            resp.lowerCritical = static_cast<uint8_t>(
-                (critLow - info.scaledOffset) / info.coefficientM);
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
-        }
+    double critLow = ipmi::mappedVariant<double>(critThresholds,
+            "CriticalLow", std::numeric_limits<double>::quiet_NaN());
+    double critHigh = ipmi::mappedVariant<double>(critThresholds,
+            "CriticalHigh", std::numeric_limits<double>::quiet_NaN());
 
-        if (std::isfinite(critHigh))
-        {
-            critHigh *= std::pow(10, info.scale - info.exponentR);
-            resp.upperCritical = static_cast<uint8_t>(
-                (critHigh - info.scaledOffset) / info.coefficientM);
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
-        }
+    if (std::isfinite(critLow))
+    {
+        critLow *= std::pow(10, info.scale - info.exponentR);
+        resp.lowerCritical = static_cast<uint8_t>(
+            (critLow - info.scaledOffset) / info.coefficientM);
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
+    }
+
+    if (std::isfinite(critHigh))
+    {
+        critHigh *= std::pow(10, info.scale - info.exponentR);
+        resp.upperCritical = static_cast<uint8_t>(
+            (critHigh - info.scaledOffset) / info.coefficientM);
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
     }
 
     return resp;
-- 
2.25.1

