From 485e9a7c343aff9d432b7fcf5340925ac8040b62 Mon Sep 17 00:00:00 2001
From: "chaul.ampere" <chaul@amperecomputing.com>
Date: Wed, 24 Aug 2022 17:03:37 +0700
Subject: [PATCH 6/6] Add json action to set target from group max

The patch adds an action to set target of Zone to a value corresponding to the maximum
value from maximum group property value. The mapping is based on a provided
table. If there are more than one event using this action, the maximum speed
derived from the mapping of all groups will be set to the zone's target.

...
{
    "name": "target_from_group_max",
    "groups": [
        {
          "name": "zone0_ambient",
          "interface": "xyz.openbmc_project.Sensor.Value",
          "property": { "name": "Value" }
        }
    ],
    "neg_hysteresis": 1,
    "pos_hysteresis": 0,
        "index": 0,
    "map": [
        { "value": 10.0, "target": 38.0 },
        ...
    ]
}

The above JSON will cause the action to read the property specified in the
group "zone0_ambient" from all members of the group. The change in the group's
members value will be checked against "neg_hysteresis" and "pos_hysteresis"
to decide if it is worth taking action. "neg_hysteresis" is for the increasing
case and "pos_hysteresis" is for the decreasing case. The maximum property value
in the group will be mapped to the "map" to get the output "target".
Each configured event using this action will have "index" as a key in a static map
to store its mapping result. The static map will be shared across the events of this
action. Therefore, the updated "target" value derived from "zone0_ambient" will be
stored in that static map with its own key. Each time it calls this action running
for each event, after the new value is updated to the static map, the maximum value
from it will be used to set to the Zone's target.

Signed-off-by: Chau Ly <chaul@amperecomputing.com>
---
 .../json/actions/target_from_group_max.cpp    | 280 ++++++++++++++++++
 .../json/actions/target_from_group_max.hpp    | 156 ++++++++++
 control/meson.build                           |   1 +
 3 files changed, 437 insertions(+)
 create mode 100644 control/json/actions/target_from_group_max.cpp
 create mode 100644 control/json/actions/target_from_group_max.hpp

diff --git a/control/json/actions/target_from_group_max.cpp b/control/json/actions/target_from_group_max.cpp
new file mode 100644
index 0000000..de57180
--- /dev/null
+++ b/control/json/actions/target_from_group_max.cpp
@@ -0,0 +1,273 @@
+/**
+ * Copyright © 2021 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "target_from_group_max.hpp"
+
+#include "../manager.hpp"
+
+#include <fmt/format.h>
+
+namespace phosphor::fan::control::json
+{
+
+std::map<size_t, uint64_t> TargetFromGroupMax::_speedFromGroupsMap;
+size_t TargetFromGroupMax::_groupIndexCounter=0;
+
+using json = nlohmann::json;
+using namespace phosphor::logging;
+
+TargetFromGroupMax::TargetFromGroupMax(const json& jsonObj,
+                                       const std::vector<Group>& groups) :
+    ActionBase(jsonObj, groups)
+{
+    setHysteresis(jsonObj);
+    setIndex();
+    setMap(jsonObj);
+}
+
+void TargetFromGroupMax::run(Zone& zone)
+{
+    // Holds the max property value of groups
+    auto maxGroup = processGroups();
+
+    // Group with non-numeric property value will be skipped from processing
+    if (maxGroup)
+    {
+        /*The maximum property value from the group*/
+        uint64_t groupValue = static_cast<uint64_t>(std::get<double>(maxGroup.value()));
+        
+        // Only check if previous and new values differ
+        if (groupValue != _prevGroupValue)
+        {
+            /*The speed derived from mapping*/
+            uint64_t groupSpeed = _speedFromGroupsMap[_groupIndex];
+
+            // Value is decreasing from previous  && greater than positive
+            // hysteresis
+            if ((groupValue < _prevGroupValue) &&
+                (_prevGroupValue - groupValue > _posHysteresis))
+            {
+                for (auto it = _valueToSpeedMap.rbegin();
+                     it != _valueToSpeedMap.rend(); ++it)
+                {
+                    // Value is at/above last map key, set speed to the last map
+                    // key's value
+                    if (it == _valueToSpeedMap.rbegin() &&
+                        groupValue >= it->first)
+                    {
+                        groupSpeed = it->second;
+                        break;
+                    }
+                    // Value is at/below first map key, set speed to the first
+                    // map key's value
+                    else if (std::next(it, 1) == _valueToSpeedMap.rend() &&
+                             groupValue <= it->first)
+                    {
+                        groupSpeed = it->second;
+                        break;
+                    }
+                    // Value decreased & transitioned across a map key, update
+                    // speed to this map key's value when new value is at or
+                    // below map's key and the key is at/below the previous
+                    // value
+                    if (groupValue <= it->first && it->first <= _prevGroupValue)
+                    {
+                        groupSpeed = it->second;
+                    }
+                }
+                _prevGroupValue = groupValue;
+                _speedFromGroupsMap[_groupIndex] = groupSpeed;
+
+                // Get the maximum speed derived from all groups, and set target
+                // for the Zone
+                auto maxSpeedFromGroupsIter = std::max_element(
+                    _speedFromGroupsMap.begin(), _speedFromGroupsMap.end(),
+                    [](const auto& x, const auto& y) {
+                        return x.second < y.second;
+                    });
+                
+                zone.setTarget(maxSpeedFromGroupsIter->second);
+            }
+            // Value is increasing from previous && greater than negative
+            // hysteresis
+            else if((groupValue > _prevGroupValue) &&
+                (groupValue - _prevGroupValue > _negHysteresis))
+            {
+                for (auto it = _valueToSpeedMap.begin();
+                    it != _valueToSpeedMap.end(); ++it)
+                {
+                    // Value is at/below the first map key, set speed to the
+                    // first map key's value
+                    if (it == _valueToSpeedMap.begin() &&
+                        groupValue <= it->first)
+                    {
+                        groupSpeed = it->second;
+                        break;
+                    }
+                    // Value is at/above last map key, set speed to the last
+                    // map key's value
+                    else if (std::next(it, 1) == _valueToSpeedMap.end() &&
+                                groupValue >= it->first)
+                    {
+                        groupSpeed = it->second;
+                        break;
+                    }
+                    // Value increased & transitioned across a map key,
+                    // update speed to the next map key's value when new
+                    // value is above map's key and the key is at/above the
+                    // previous value
+                    if (groupValue > it->first &&
+                        it->first >= _prevGroupValue)
+                    {
+                        groupSpeed = std::next(it, 1)->second;
+                    }
+                    // Value increased & transitioned across a map key,
+                    // update speed to the map key's value when new value is
+                    // at the map's key and the key is above the previous
+                    // value
+                    else if (groupValue == it->first &&
+                                it->first > _prevGroupValue)
+                    {
+                        groupSpeed = it->second;
+                    }
+                }
+                _prevGroupValue = groupValue;
+                _speedFromGroupsMap[_groupIndex] = groupSpeed;
+
+                // Get the maximum speed derived from all groups, and set target
+                // for the Zone
+                auto maxSpeedFromGroupsIter = std::max_element(
+                    _speedFromGroupsMap.begin(), _speedFromGroupsMap.end(),
+                    [](const auto& x, const auto& y) {
+                        return x.second < y.second;
+                    });
+                
+                zone.setTarget(maxSpeedFromGroupsIter->second);
+            }           
+        }
+    }
+}
+
+void TargetFromGroupMax::setHysteresis(const json& jsonObj)
+{
+    if (!jsonObj.contains("neg_hysteresis") ||
+        !jsonObj.contains("pos_hysteresis"))
+    {
+        throw ActionParseError{
+            ActionBase::getName(),
+            "Missing required neg_hysteresis or pos_hysteresis value"};
+    }
+    _negHysteresis = jsonObj["neg_hysteresis"].get<uint64_t>();
+    _posHysteresis = jsonObj["pos_hysteresis"].get<uint64_t>();
+}
+
+void TargetFromGroupMax::setIndex()
+{
+    _groupIndex = _groupIndexCounter;
+    //Increase the index counter by one to specify the next group key
+    _groupIndexCounter += 1;
+    
+    // Initialize the map of groups and their max values
+    _speedFromGroupsMap[_groupIndex] = 0;
+}
+
+void TargetFromGroupMax::setMap(const json& jsonObj)
+{
+    if (jsonObj.contains("map"))
+    {
+        for (const auto& map : jsonObj.at("map"))
+        {
+
+            if (!map.contains("value") || !map.contains("target"))
+            {
+                throw ActionParseError{ActionBase::getName(),
+                                       "Missing value or target in map"};
+            }
+            else
+            {
+
+                uint64_t val = map["value"].get<uint64_t>();
+                uint64_t target = map["target"].get<uint64_t>();
+                _valueToSpeedMap.insert(
+                    std::pair<uint64_t, uint64_t>(val, target));
+            }
+        }
+    }
+
+    else
+    {
+        throw ActionParseError{ActionBase::getName(), "Missing required map"};
+    }
+}
+
+std::optional<PropertyVariantType> TargetFromGroupMax::processGroups()
+{
+    // Holds the max property value of groups
+    std::optional<PropertyVariantType> max;
+    for (const auto& group : _groups)
+    {
+        const auto& members = group.getMembers();
+        for (const auto& member : members)
+        {
+            PropertyVariantType value;
+            bool invalid = false;
+            try
+            {
+                value = Manager::getObjValueVariant(
+                    member, group.getInterface(), group.getProperty());
+            }
+            catch (const std::out_of_range&)
+            {
+                continue;
+            }
+
+            // Only allow a group members to be
+            // numeric. Unlike with std::is_arithmetic, bools are not
+            // considered numeric here.
+            std::visit(
+                [&group, &invalid, this](auto&& val) {
+                    using V = std::decay_t<decltype(val)>;
+                    if constexpr (!std::is_same_v<double, V> &&
+                                  !std::is_same_v<int32_t, V> &&
+                                  !std::is_same_v<int64_t, V>)
+                    {
+                        log<level::ERR>(fmt::format("{}: Group {}'s member "
+                                                    "isn't numeric",
+                                                    ActionBase::getName(),
+                                                    group.getName())
+                                            .c_str());
+                        invalid = true;
+                    }
+                },
+                value);
+            if (invalid)
+            {
+                break;
+            }
+
+            if (max && (value > max))
+            {
+                max = value;
+            }
+            else if (!max)
+            {
+                max = value;
+            }
+        }
+    }
+    return max;
+}
+
+} // namespace phosphor::fan::control::json
diff --git a/control/json/actions/target_from_group_max.hpp b/control/json/actions/target_from_group_max.hpp
new file mode 100644
index 0000000..2016724
--- /dev/null
+++ b/control/json/actions/target_from_group_max.hpp
@@ -0,0 +1,156 @@
+/**
+ * Copyright © 2021 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include "../utils/modifier.hpp"
+#include "../zone.hpp"
+#include "action.hpp"
+#include "group.hpp"
+
+#include <nlohmann/json.hpp>
+#include <iostream>
+
+namespace phosphor::fan::control::json
+{
+
+using json = nlohmann::json;
+
+/**
+ * @class class TargetFromGroupMax : - Action to set target of Zone to
+ * a value corresponding to the maximum value from group's member
+ * properties. The mapping is according to the map. 
+ *
+ * If there are more than one group using this action, the maximum speed
+ * derived from the mapping of all groups will be set to target.
+ *
+ * For example:
+ *
+ *  {
+      "name": "set_parameter_from_group",
+      "groups": [
+            {
+              "name": "zone0_ambient",
+              "interface": "xyz.openbmc_project.Sensor.Value",
+              "property": { "name": "Value" }
+            }
+          ],
+      "neg_hysteresis": 1,
+      "pos_hysteresis": 0,
+      "map": [
+            { "value": 10.0, "target": 38.0 },
+            ...
+      ]
+    }
+  
+ *
+ * The above JSON will cause the action to read the property specified
+ * in the group from all memebers of the group, the change in the property
+ * value everytime will be checked against "neg_hysteresis" and "pos_hysteresis"
+ * to decide if it worths taking action, "neg_hysteresis" is for the increasing case
+ * and "pos_hysteresis" is for the decreasing case. The maximum value property value
+ * in a group will be mapped to the "map" to get the output "target". The updated "target"
+ * value of each group will be stored in the _speedFromGroupsMap static map with key.
+ * The maximum value from the _speedFromGroupsMap map will be used to set to the Zone's target.
+ *
+ */
+class TargetFromGroupMax :
+    public ActionBase,
+    public ActionRegister<TargetFromGroupMax>
+{
+  public:
+
+    /* Name of this action */
+    static constexpr auto name = "target_from_group_max";
+
+    TargetFromGroupMax() = delete;
+    TargetFromGroupMax(const TargetFromGroupMax&) = delete;
+    TargetFromGroupMax(TargetFromGroupMax&&) = delete;
+    TargetFromGroupMax&
+        operator=(const TargetFromGroupMax&) = delete;
+    TargetFromGroupMax& operator=(TargetFromGroupMax&&) = delete;
+    ~TargetFromGroupMax() = default;
+
+    /**
+     * @brief Constructor
+     *
+     * @param[in] jsonObj - JSON configuration of this action
+     * @param[in] groups - Groups of dbus objects the action uses
+     */
+    TargetFromGroupMax(const json& jsonObj,
+                             const std::vector<Group>& groups);
+
+    /**
+     * @brief Reads a property value from the configured group,
+     *        get the max, do mapping and get the target.
+     *
+     * @param[in] zone - Zone to run the action on
+     */
+    void run(Zone& zone) override;
+
+  private:
+
+    /*The previous maximum property value from group used for checking against hysteresis*/
+    uint64_t _prevGroupValue=0;
+
+    /*The table of maximum speed derived from each group using this action*/
+    static std::map<size_t, uint64_t> _speedFromGroupsMap;
+
+    /*The group index counter*/
+    static size_t _groupIndexCounter;
+
+    /*The table of previous maximum property value from each group in an event used for checking against hysteresis*/
+    //std::map <std::string, uint64_t> _prevGroupValueMap;
+
+    /*The Hysteresis parameters from config*/
+    uint64_t _negHysteresis = 0;
+    uint64_t _posHysteresis = 0;
+
+    /*The group index from config*/
+    size_t _groupIndex = 0;
+
+    /*The mapping table from config*/
+    std::map <uint64_t, uint64_t> _valueToSpeedMap;
+
+    /**
+     * @brief Read the hysteresis parameters from the JSON
+     *
+     * @param[in] jsonObj - JSON configuration of this action
+     */
+    void setHysteresis(const json& jsonObj);
+
+    /**
+     * @brief Provide index for group
+     *
+     * @param[in] jsonObj - JSON configuration of this action
+     */
+    void setIndex();
+
+    /**
+     * @brief Read the map from the JSON
+     *
+     * @param[in] jsonObj - JSON configuration of this action
+     */
+    void setMap(const json& jsonObj);
+
+    /**
+     * @brief Process through all groups of the event and return the maximum property value
+     *
+     * @param[in] jsonObj - JSON configuration of this action
+     */
+    std::optional<PropertyVariantType> processGroups();
+};
+
+} // namespace phosphor::fan::control::json
diff --git a/control/meson.build b/control/meson.build
index 5225b0c..e5a6231 100644
--- a/control/meson.build
+++ b/control/meson.build
@@ -40,6 +40,7 @@ if conf.has('CONTROL_USE_JSON')
         'json/actions/pcie_card_floors.cpp',
         'json/actions/request_target_base.cpp',
         'json/actions/set_parameter_from_group_max.cpp',
+        'json/actions/target_from_group_max.cpp',
         'json/actions/timer_based_actions.cpp',
         'json/utils/flight_recorder.cpp',
         'json/utils/modifier.cpp',
-- 
2.25.1
